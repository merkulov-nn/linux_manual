команды лннукс

touch создает текстовый документ( файл) 
whoami команда чтобы узнать кто мы
pwd где я
history  показвает историю команд которыми мы пользовались
ls -l вывдит информацию о файле, какое права, размер, дату и время создания
ls -a команда позволяет посмотреть файлы которые начитаются с точки 
ls -al команда позволяет увидеть кто создал файл, когда создал файл и кто его может использовать 
heat -n вывдет первый 10 строк фала

tail -n выводит посоедние 10 строк файла 

less позволяет прочитать большой файл и листать его. Если нам нужно найти конкретоные символы или слова мы пишем слеш(/) и т что хотим найти

| позволяет объеденять команды 


cat позволяет посмотреть что находиться в файле. но так же мы можем с помощью него создавать файл
или заменять содержимое файла в другой файл, с помощью (>) также мы можем дополнить файл другими данныи из другого файла (>>)
Пример: cat 1.txt>2.txt мы из файла  1.txt перекинули информацию в файл 2.txt  Помните что одна (>) удаляет сатарую инфу в файле и и переписует его новой инфой. 
Пример: cat 1.txt>>2.txt мы взяли инфу из 1.txt и дополнили ее в 2.txt
Так же мы можеи брать информацию из других файлов и передавать его в друго файл ипользуя тока одну стрелочку (>)

gpep позволяет искать информацию по каким либо строчкам 
Пример: grep it<1.txt Мы ищем  все строчки где есть слово it в файле 1.txt

mount нужна для подключения (монтирования) файловых систем и персональных накопителей (usb-флешка, карты памят) 
к конкретным точкам монтирования в дереве директорий. 

Пример: mount -t тип файловой системе - ключи опций - непосредственно устройство  - куда? тоесть точка монтирования 
mount /dev/fd /home/nikolay/
такж команда maunt позволяет переносить данные из флешки в любую директорию линукса.

Основные опции команды mount

-t — тип монтируемой файловой системы
-v — подробная информация о процессе монтирования
-a — примонтировать все устройства, описанные в fstab
-f — холостой запуск — что будет сделано при реальном запуске
-r — монтировать файловую систему только для чтения
-w — монтировать файловую систему для чтения и записи
-U — монтировать файловую систему по UUID
Основные опции монтирования

ro — смонтировать файловую систему только для чтения
rw — смонтировать файловую систему для чтения-записи
sync — операции ввода-вывода в ФС должны выполняться синхронно
async — операции ввода-вывода в ФС должны выполняться асинхронно
exec — разрешить выполнение двоичных файлов
auto — ФС может быть смонтирована при запуске mount с опцией -a
noauto — ФС может быть смонтирована только явно
defaults — эквивалентно rw,suid,dev,exec,auto,nouser,async

umount команда для размонтирования 
Пример: umount то что мы хотим размонтировать. 

чтобы удалить замонтироваемый диск его сперва мужно размонтировать командой umnout 


Управление пакетами. 

Репозиторий это набор програмного обеспечения которая собрана отосительно какой либо библиотеке 

Чем пакет отличается от некого  инстолятора: 
Инстолятор это пу сути то что имеет в себе некую сущьность для разертывание програмного обеспечения. 
У пакета структура другая. Он состоит из само собой програмноо обеспечения которая развертывается, он так же состоит из следующих вещей, которая четка прям диклорированы (объявлены) внутри каждого пакета 
Это и конфигурационные файлы 
Это и некая управляющая информация, которая в том числе  используется для развертывание програмного обеспечения 
Контролные суммы всех файлов, они тоже храняться в пакетах. Это постустоновочные неки скрипты, тоесть что нужно сделать после развертывание пакета в системе 
Если вязить приимер из винды. это работает так. мы устанвили програму и на рабочем столе появися ярлык програмы ( значек) ну как пример постустановочного скрипта/ команда поиска в vim 
Так же в пакете храняться скрипты которые будут вызываться перед удаением пакета 
И набор неких скриптов которые вызываются уже после удаление пакета   

dpkg можно использовать в место apt но это очень опасно и он самый нижний уровень по управлению пакетов, по утмновке по удалению 

apt это утилита для установки пакетов. Но она внутри себя так же использует утилиту dpkg и базаруется именно на ней 
apt пр установки всегда следит за зависимотями и вседа подтягивает пакеты и после это гарантировно будет работать 
update команда чтобы посмотреть если ли обновления или нет 
upgrade обновлет пакета не удаляя старые версии. Но она не может поменять на другую версию. а просто ее обновит до последней версию.

Основные команды: для утилиты apt
  list - показать список пакетов на основе указанных имён
  search - искать в описаниях пакетов
  show - показать дополнительные данные о пакете
  install - установить пакеты
  reinstall - переустановить пакеты
  remove - удалить пакеты
  autoremove - автоматически удалить все неиспользуемые пакеты
  update - обновить список доступных пакетов
  upgrade - обновить систему, устанавливая/обновляя пакеты
  full-upgrade - обновить систему, удаляя/устанавливая/обновляя пакеты
  edit-sources - редактировать файл с источниками пакетов
  satisf- удовлетворить строки зависимосте

apt moo посхалка 

Vim команды 

shift+a команда для редактирование 
:q команда выхода из редактора 
:w сохранить изменения(если файл без имени то после ввода команды добавить имя) Пример: :w имя файла 
dd  команда чтобы удалить отдельную строку  
shift+v выделает полностью строку 
v можно выделеить самостоятельно 
y копирует строку 
p вставляет скопированый текст 
set number комнда нумерует строки 
shift : чтобы перейти в режим ввода команд
split команда которая позволяет откруыть второе окно редактора. Привер: split имя файла (если нет файла он его создаст)
vsplit откроет второй файл то тока откроят его вертикальный.
ctrl+w+курсор команда чтобе переходить между открытыми окнами редактора. Или ctrl+ww
wq команда чтобы сразу записать файл и выйти из него 
/ команда поиска в vim 
n команда чтобы переходить по найденным значением с помощью поисковика vim 
shifn+n команда чтобы вернуться на предедущее значения в поисковике vim 


Управление пользовательскими группами 

Лонгин и пароль, это первичный способ защиты и идентификации, но не является однозначенным способом идентифицировать пользователя 

Группа это способ объеденения пользователей чтобы раздавать им центаризованные права ну или лишать их 
Операционная система незнает пользоваьеля там с именем Маша, Коля, или Юра 
Операционная система работает тока с UID идетификатором пользователя 
UID или USER ID Это уникалый идентификатор, назначенный каждому пользователю в системе
Он используется для определения тех, кто владеет файлами и каталогами и какие права доступа у них есть.
UID может быть любым числом от 0 до 65535. В большенство дистрибутивов Linux UID 0 зарегестрирован для суперпользователя (root)
GID или Group ID. Это идентификатор группы, назначенный каждой группе пользователей в системе. 


Создане пользователей, модификация и удление
 
useradd команда для создание пользователй
 
/etc/paswd/ в этой директории храняться данные о пльзователей

getent команды чтобы делать выборку из файла и так жк можно проверять наличие новых пользователей

Пример: getent passwd Ylia - этой командой мы смотрим есть ли  у нас в системе пользователь Ylia. И он нам покажет результат. Соответственно это все надо делать с правами супер пользователя.
        Ylia:x:1001:1001::/home/Ylia:/bin/sh  и так, мы видим, что такой пользователь есть. У него 10001 номер, система сама назначает номер, 10001 группа, так как они так же не занята,
        его домашняя директория /home/Ylia и его шел (shell)  /bin/sh
	useradd kliff -m -d /home/kliff -k /home/nikolay -s /bin/bash 
	Описания:: мы хотим создать пользовтеля с именем kliff, -m -d это ключит для домашней директори /home, -k откудо подтянть файлы, мы подтягиваем файлы из /home/nikolay, все файла которрые хрянаться 	    в домашней директории /home/nikolay появятся у пользователя kliff, и оболочка /bin/bash. Так как мы скопировали файлы и директории /home/nikolay то пользователь kliff может их изменять, 
	так как у него есть полный доступ на них
 
        shell(оболочка)  Это команда обеспецивающая взаимодействие пользователся с системой.  В командной строке вы вводите команды, котрые оболочка интерпритирует, вызывает
        соответствующие прогаммы и отоброжает результаты. Команды могут подаваться не только в текстовом режиме, но и считываться из файла, называемого shell-скриптом или оболочкой shell-программы
        Поосле того как мы создали новоого пользователя и чтобы он мог войти, нужно создать ема пароль командой passwd Ylia(имя пользовател)
        passwd кооманда для создания пароля для пользователей.
        Но когда пользователь Ylia зайдет на свой создынный аккаунт, у нее там не будет домашней директории. и ее нужно создать, командой mkdir Ylia(имя домашней диретории) 


	Bash это командная оболочка для UNIX-подобных операционных систем (Linux, MacOS). ОНа преедставляет пользователю систему команд для работы с файлами и папкими, поиском, настроойкой окружения и 
	позволяет управлять ОС прям с командной строки 
	Оболочка принимает команды,  которые пользовтель ввл в командную строку, и интерпритирует их, то есть переволит в машинный код. Операционная система получат код в качестве инструкций и выполняет
	их
	Так же можно создавать bash или shell-скрипты, которые сохраняются в файле. При каждом запуске файла будет выполняться набор указанных в нем команд 




        
cat /etc/nsswitch.conf  он показывает то откуда подтягиваются информация для поиска данныз о пользователях, группах и т.д. Это список источноков

Но у нас есть возможность  автоматизировать процесс созданиие пользователей 

adduser создает пользователей в системе.
 
	Она работает на более высоком уровне и является интерактивной. При использования adduser достаточно задать имя пользователя, а далее  утилита автоматически создаст одноименную группу для 
	пользователя, 
	домашний каталог в директории /home, предложит задать пароль, а также заполнит такую информацию, как полное имя, номер кабинета, рабочий телефон, доманий телефон, и 
	любую другую информцию, которую вы посчитаете нужной 
 После того как мы создали пользователя ы увидет такую информацию 
	info: Adding user `igor' ...
	info: Selecting UID/GID from range 1000 to 59999 ...
	info: Adding new group `igor' (1002) ...
	info: Adding new user `igor' (1002) with group `igor (1002)' ...
	info: Creating home directory `/home/igor' ...
	info: Copying files from `/etc/skel' ...
	
	Нам интересна последняя строчка info: Copying files from `/etc/skel' это копирование файлов, которая идет из /etc/skel' это так называемый скелет директории, если вы сюда что то поместите,
	то при создание пользователя оно автоматчски попадет ко всем остальным пользователям. Это может быть какой то набор инструкций, чтобы у каждого ползователя при создании, были одинаковые инструкции

Модификации пользователей 

usermod  с различными ключами, команда чтобы изменять параметры пользователей и также чтобы поменять группу у пользователя 

	-d изменет домашний каталог
	-m -d он переместит домашний катологс его содержимым
	-l изменения имени пользователя. Пример: usermod Ylia -l vova (старрая имя пользователя -l новое имя пользователя)
	-s меняет оболочку. Пример: usermod Ylia -s /bin/bash (имя пользоватля -s оболочка /bin/bash)
	-r удаляем все каталоги и файлы из в месте с ползователем
	-g чтобы поменять или добавить главную(первичную)  группу для пользователя. Пример: usermod -g имя новой  группы. Каждый пользователь должен принадлежать ровно одной основной(первичной) группе 
        -G чтобы добавить вторичные группы. Можно добавлять несколько вторичных групп срузу, чрез запятую. Пример: usermod Ylia -G igor, cdrom, natasha. Мы для пользователя Ylia добавили три вторичные 
	группы igor, cdrom, natasha. Так же моожно первичную группу селать вторичную, и на оборот   
	-a команда которая позволяет добавить к вторичным группам еще одну группу, не удаляя старые группы 
	-s позволяет менять оболочки, на любоу другую. Напаример можно заблокировать доступ пользователя в первичную группу написав команду (usermod Ylia -s /bin/false или usermod Ylia -s /sbin/nologin. 
	   Грубо говоря мы 
	   мы поставили загрушку для пользователя Ylia чтобф он не мог войти к себе в группу.
userdel удаляет пользовтеля из системы но не удалет его файлы. Чтобы удалить и пользователя и файлы надо написать ключ -r
	Пример: userdel -r имя пользователя


Назначения групп

Основа распределения прав доступа в в операционной ситеме в Linux лежит на понятии пользователь. Пользвателю владельцу файла выдаются определенные полномочия для работы с ним, а именно чтение, запись, и 
исполнеения.
Так же отдельно устонавливаются полномочия на чтения, запись и выполнени для всех остальных пользователей. Посколку в линуксе все есть файл, то такая система позволяет регулировать доступ к 
любому действию в этой операционной системе с помощью установки прав доступа на файлы 
	Группа в linux нужна для разгроничения прав доступа к различным компонентам системы.
	Каждая группа, как и отдельный пользователь, обладает набором прав и доступа к различным компонентам системы. Каждый пользователь член этой группы автоматически получает все права вэтой группы 
	
	Группа позволяет группировать пользоветелей по принцыпу одинаковых полномочий  на какое либо действия. Каждый пользователь может состоять в неоограниченном количестве групп,	
	и в каждой может быть сколько угодно пользоователей. 

В Linux сущестует два типо групп для ползователей
	1. Первичная группа (группа входав систему) - эта группа которая назначается файлам, создавамым пользователем. Обычно имя основной группы совпадает с именеп пользователя.
	   Каждый пользователь должен принадлежать ровно к одной основной группе.
	2. Вторичная грууппа (допонительная группа)  - это группа, которая использует для предоставления определенных привелеегий пользователю. Пользователь может быть участником не оной а сразу 
	   нескольких вторичных групп 
	

Группа у каждого пользоатля бывает главная и вторичная, все они находяться внутри одного файла. Файл называется ( /etc/group)

groups команада для простотра гуппы пользователя.
addgroup команда чтобы создать группу ( addgroup имя группы которую хотим создать)
groupdel удаение групп 
 
Конфигупация пользователей 

 если мы посмотрим, что нахолиться в директории /etc/motd, то мы увидем сообщени которая у нас появляется при входе в операцинную систему. При необходимости мы можем этот файл отредактировать 
и можем выводить какое нибуть иное сообщение, отличное от исход

Блокировка пользователей

	usermod -L  команда чтобы забокировать пользователя ( -L  ключь для блокировки пользователя) Пример: usermod Ylia -L - мы заблокировали пользовтеля Ylia
	usermod -U  команда для разблокировки пользователя  ( -U ключь для разблокировки пользователя)  Пример: usermod Ylia -U  мы разблокировли пользователя Ylia
	usermod -e  команда поозволяет поставить дату на блокировку пользвателя. Пример: usermod Ylia -e 2024.12.20  Нам надо чтобы пользователь заблокировался 2024.12.20 и он заблокируется в эту дату 

chage команда чтобы посмотреть информацию по пользователю а именно.


 
	   



Символичесие и жесткие ссылки

	Символические и жесткие ссылки - это особенность файловой системы Linux, которая позволяет размещать один и тот же файл в нескольких директориях. 
	Это очень похоже на ярлыки в Windows, так как файл на самом деле остается там же где и был, но вы можете на него сослаться из любого другого места.
	Пользователь не должен существовать в операционной системе бесконечно. почему не должен, он может уволиться а уего учетка останеться и через его учетку могу зайти 

	В Linux существует два типа ссылок на файлы. Это символические и жесткие ссылки Linux. Они очень сильно отличаются и каждый тип имеет очень важное значение. 
	В этой небольшой статье мы рассмотрим чем же отличаются эти ссылки, зачем они нужны, а также как создавать ссылки на файлы в Linux.






Символические ссылки

	Символические ссылки более всего похожи на обычные ярлыки. Они содержат адрес нужного файла в вашей файловой системе. Когда вы пытаетесь открыть такую ссылку, то открывается целевой файл или папка 	    Главное ее отличие от жестких ссылок в том, что при удалении целевого файла ссылка останется, но она будет указывать в никуда, поскольку файла на самом деле больше нет.






Вот основные особенности символических ссылок:

    Могут ссылаться на файлы и каталоги;
    После удаления, перемещения или переименования файла становятся недействительными;
    Права доступа и номер inode отличаются от исходного файла;
    При изменении прав доступа для исходного файла, права на ссылку останутся неизменными;
    Можно ссылаться на другие разделы диска;
    Содержат только имя файла, а не его содержимое.




Теперь давайте рассмотрим жесткие ссылки.

Жесткие ссылки

	Этот тип ссылок реализован на более низком уровне файловой системы. Файл размещен только в определенном месте жесткого диска. Но на это место могут ссылаться несколько ссылок из файловой системы. 	    Каждая из ссылок - это отдельный файл, но ведут они к одному участку жесткого диска. Файл можно перемещать между каталогами, и все ссылки останутся рабочими, поскольку для них неважно имя. 





Рассмотрим особенности:

    Работают только в пределах одной файловой системы;
    Нельзя ссылаться на каталоги;
    Имеют ту же информацию inode и набор разрешений что и у исходного файла;
    Разрешения на ссылку изменятся при изменении разрешений файла;
    Можно перемещать и переименовывать и даже удалять файл без вреда ссылке.

$ ln опции файл_источник файл_ссылки

Рассмотрим опции утилиты:

    -d - разрешить создавать жесткие ссылки для директорий суперпользователю;
    -f - удалять существующие ссылки;
    -i - спрашивать нужно ли удалять существующие ссылки;
    -P - создать жесткую ссылку;
    -r - создать символическую ссылку с относительным путем к файлу;
    -s - создать символическую ссылку.







- d l b c ( c этих символов всегда начинается строка, которая показывает какие права существуют над объектом) 
	- это файл или просто ноль, если мы хотим задавть права на обычный файл 
	d - это директория 
	l - это символьная ссылка. Символьная ссылка (symbolic link) - эта специальный файл, который является ссылкой на другой файл или каталог. 
	    Символьческие ссылки также газывают символьными, мягкими ссылками (soft links) или сим ссылками (sym-link)
            Они не содержат внутри себя копии самого файла, на которрый указывают, и являются всего лишь указателями на файл. При этом символические ссылки обладают собственными правами доступа
            так как сама являтся небольшим файлом, которая содержит путь до другого файла 
            Можно сооздовать несколько символических ссылок на один файл и эти ссылки могут иметь разные имена.
	b - блочное устройство Блочное устройство (block device) — вид файла устройств в UNIX/Linux-системах, обеспечивающий интерфейс к устройству, реальному или виртуальному, 
	    в виде файла в файловой системе. 
	    С блочным устройством обеспечивается обмен данными блоками данных. Как правило, это устройства произвольного доступа, т.е. можно указать, из какого именно места должен быть прочитан или
	    записан блок данных. Данные, при чтении или записи на блочное устройство буферизуются.
            Типичные примеры блочных устройств: жёсткий диск, CD-ROM, флоппи-дисковод. 
            Файл устройства /dev/fd0 флоппи-дисковода: 
	с - символное устройство 
	    Символьное устройство — (character device) — вид файла устройства в UNIX/Linux-системах, обеспечивающий интерфейс к устройству, реальному или виртуальному, 
	    с возможностью посимвольного обмена информацией. 	 	    
            Символьное устройство — (character device) — вид файла устройства в UNIX/Linux-системах, обеспечивающий интерфейс к устройству, реальному или виртуальному, 
	    с возможностью посимвольного обмена информацией. 	
	    В отличие от блочного устройства символьное устройство, как правило, не обладает возможностями произвольного доступа. 
            В большинстве своём, чтение и запись данных в символьное устройство не буферизуется.

            Типичные примеры символьных устройств: стриммер, модем, телетайп или терминал.

            Файл устройства /dev/ttyS0 последовательного порта: 

       -rwxrwxrwx читат-записывать исполнять(read-write-execute). Первые три (бата) значение это то, что может делать над файлом владелец, какого тожет не быть,                                                     	      так же у них есть числовые значения это нужно для того, чтобы менять  права у пользователей
		  r - это чтение
		  w - запись
, 	          x  - это исполнение  
		  Первые три бита(значения)  это то, что может делать над файлом владелец группы 
	          Следующие три (бита) значения  идет, что может совершать над файлом члены группы владельца.(допустим они только могут читать -r-xr--rwx)
	  	  Последдние три (бита) значения - это то, что могут делать над файлом все остальные. (допустим все остальные могут тока исполнять файл -r-xr----x)




Как менять права пользователей:
У прав доступа есть аткже числовые значение - это сдлано для удобства и скорости предоставление прав пррав доступа.
rwxr: r=4 
      w=2,  
      x=1. Для предоставление доступа их сумиркют.

chmod -  команда для изменение прав доступа

Пример: chmod 0761 222.txt (0 (ноль)- это означает что мы хотим дать права на файл, 4+2+1 = 7, 7 означает что мы хотим владельцу дать полные праввав на фал, далее 4+2 = 6 это означает что мы членам группы	     владельца хотим дать права только на чтение и запись. А  для всех остальных только исполнения  
Если нам надо изменить права во всем каталоге то мы приминяем утилиту -R(рекурсивно) 
	Пример: chmod -R 777 linux. Что мы видим, мы доавляем полные  права на все файлы которые находяться в каталоге linux. Всем файлам которые находяться в каталоге linux мы дали права на чтение
	запись и исполнения неограниченно для всех пользователей.

Также чтобы изменять права можно использовать символьные значение(буквенные)
	u - юзира(владельца группы)
	g - это для группы
	o - для всех остальных 
	a - это для всех
Пример: chmod u=w, g=w, o=w 222.txt	 



Изменения пользователя 

		chmod -v root linux.txt (мы у файла linux.txt  меняем права на root тобишь мы меняего поменли его права на супер пользователя) Если не поолучается поменять пользователя, то надо перейти в 
                                        супер пользователя.
		-v показвает какие измнения произошли чтобы посмотреть что у нас будет изменятся 
  		
		chmod -v fox:ylia file.txt (И так что мы делаем: Мы у файла file.txt менем владельца на fox и основная группа изменена на ylia)
		chmod fox: his2  (у his2 владельцем стал fox и группой так же станем fox)
		chmod  :fox his2     ( в этом случае владельца группы мы не поменяи а вот группа поменялась теперь она fox )


бит SUID Set User ID  не безопасная команда, которрая позволяет обойти сисему безопасности действует в ее обход,
		  Она позволяет запустить некое програмное средство от именя хозяина данного средства а не от имени текущего пользователя. Очень редко используют 
бит SGID При этом случае, все файлы получают группу аналогичной родительской директории и соответстенно все остальное наслудует. 
Стики бит дает право удалать чото тока хозяину и владельцу группы.  Если активирован стики бит то удалять файлы сможет тока хозяин и root смогут удалить файлы 

Если мы на скрипт навесили бит SUID то он не будет работаить с правами владельца чтобы он заработал нам надо бит  SUID навесить на сам баш 

Стики бит:
	chmod 1777 fox   (И так, мы на каталоог fox навесили стики бит. 1 означет что у него есть стики бит а 777 это его права рава у него полные rwx, в конце прав появиться буква t)   
		         rwxrwxrwxt- t означает что стки бит на даректории  fox активирвался

Процессы:
	ps - позволяет получить информацию о процессах. он выводит прцессы без ключей для данного терминала 
	    PID TTY          TIME CMD
	    6081 pts/0    00:00:00 bash
  	    28064 pts/0    00:00:00 ps
	TTY - это на каком терминал выполняется 
	TIME - сколько процессового времени заняло 
	CMD - что за команда породила данный процес и так же показывает имя процесса 
	PID -  это идентификатор процесса 
	STAT - показает состояние процесса
	       S - sleep по другому сон ожидание или прирывестый сон, программа ожидает некого дйствия от пользователя либо со стороны другой программы или процесса 
	       R - это значит выполнется в данный момент. показывет что в данный момен выполняется команда. 
	       +  например R+ это означает что в данный момент процесс попал в группу фоновых процессов 
	       Z  процесс зомби- процесс который завршился полноситью, но пока что его не убрали потому что его ен опросил его процесс созддатель. пока завршенный процесс не опросит процесс создатель 
		  он из системы полностью не уберается  
Есть некий исходный процксс который пораждает по цепочке все процессы

top - команда которая позволяе смотреть все процессы.
      PID -  это идентификатор процесса
      PPID - идентификатор родительского процесса. Родительский роцесс это процесс который создал  (продлил) один или несколько дочерних процессов (процессов потомков) 
      USER - колличество текущих пользователей 
      PR - приоритет процесса. Процессы с более высоким приоритетом, будет обслуживаться раньше процессов с более низким приоритетом. Если процесс с более высоким приоритетом требует процессороного 
	   времени , он всегда будет обрабатываться рраньше процессов с более низким приоритетом.
      NI - ребление cpu пользовательскими процессами,и с измененным приоритетом ( командой nice или renice) 
      VIRT - это объем виртуальной памяти, который выделяется под конкретный процесс. Он обозначает общий ресурс, то есть в него входит информация, страницы памяти, коды ошибки и т.д
      RES  - это информация о том, сколько оперативной памяти относитс к процессу и указывается в килобайтах 
      SHR - это часть памяти из RES которую занимают ресурсы, доступны для использования другим процессам
      S - используется для переключения режима кумулятивного времени. Когда накопительный режим вклечен, каждый процесс отоброжется в списке с указанием процессорного времени, которое он и его мертвые
          дочерние процессы использовали. 
      CPU - показвает загруженность процессора 
      MEM - отоброжает сведени об использования оперативной памяти
	    В частности в столбце MEM указаны 
                        total - общий объем памяти 
			free - объем свободного места 
			used - объем использованной памяти 
      TIME+ показывает общее время процессора, используемое процессом м момента его начала, с точностью до сотых долей сукенды. 
      COMMAND показывет какая команда запустила той или иной процесс. 

Запуск процесса с приоритетом: 
Для чего это нужно, нам это бывает нужно, напрмер для того чтобы выдать максимальный приоритет некой программе чтобы он за ночь все это выполнил, тоесть он будет 
иметь максимальный приоитет процесорного времени
	nice - команда чтобы поставить приоритет по вреиени
	nice -n 11 vim file.txt (11 это ПРИОРИТЕТ, vim КОМАНДА, file.txt АРГУМЕНТ) 
 
Так же можно поменять текущий приоритет	 
	renice - позволяет поменять текущий преоритет. 
	renice -n 3 -p 603 (различия в  команды renice от  nice в том что чтобы поменть текущий приоритет с помощью renice нам необходимо знать PID аргумента -p это и есть PID) 

Уничтожение процессов 
		kill - позволяет завешить процесс . Пример: kill 603 - 603 это PID процесса
                killall команда позволяет удалить однотипные процессы 

Так же процесс можно убрать на задний фот  и задать ему определенный период. 
			sleep позволяет процесс перекинуть на задний фон 

	 
Базовые настройки сети линукс

	ip a - команда котора выводит информацию об интеррейсах и их настройках и так же можно посмотреть имя сетевой карты  она находиться в пункте 2
	ip addr add 192.168.0.1/24 dev enp0s3  (24 это маска подсети. Маска подсети разделяет ip адресс  на подсеть и конкретное устройство этой подсети. Он аще выглядит так 255.255.255.0, если 
				    представить это в твоичной ссистеме то мака будет выглядть так 11111111.11111111.11111111.0=24.  dev это значения имени сетево карты
			            это значит что после dev надо написать имя сетевой карты.  enp0s3 это имя сетевой карты)
	ping ip адрес команда чтобы пинговать сеть  
	 



Резвертыване DHCP сервера 
	DHCP-сервер — это специальный сервер, который автоматически распределяет и обновляет IP-адреса и другую информацию конфигурации для новых устройств в сети. 1

        DHCP (Dynamic Host Configuration Protocol) — это сетевой протокол, который упрощает управление и снижает вероятность конфликтов — назначения двум устройствам одного и того же адреса. 2

        На DHCP-сервере хранится список IP-адресов для выдачи, который называется пулом. В него входит один или несколько диапазонов последовательных адресов. 
        Сервер назначает новому устройству IP-адрес и другие параметры сетевой конфигурации — адрес шлюза по умолчанию, время аренды и прочие. 2

        DHCP-сервер облегчает процесс настройки сетевых устройств, включая пользовательские компьютеры, маршрутизаторы, смартфоны и другие.


Чтобы у нас ip адрес не менялся после каждой перезагрузке сервера, нужно поменять имя хоста. Это можно сделать в файле которай находиться по пути /etc/hostname
открываем файла  с помощью текстового редактора vim /etc/hostname и пишем новый имя хоста. старый можно удалить 

Настройка DHCP сервера 
	  Снасало нужно развернуть службу DHCP ее необхоимо скачать apt install isc-dhcp-server \
	  Даллее нам необходимо отредактировай файл vim /etc/default/isc-dhcp-server в этом файле нам надо раскоментировть две строчки и в строчку INTERFACESv4="" добавить имя интерфейса его можно глнуть           написав клманду ip a он будет в колонке 2 
												  1. DHCPDv4_CONF=/etc/dhcp/dhcpd.conf
												  2. DHCPDv4_PID=/var/run/dhcpd.pid





	 Теперь редактируем другой файл он нахолиться по пути vim /etc/dhcp/dhcpd.conf. После того как зашив этот файл, нам нужно найти строчку (open domain-name-server) стираем все лишнее чтобы у нас
	       получилась вот такая строчка (open domain-name-server) в место удаленной строчки пишем ip адес который мы хотим. 
										Например: open domain-name-server 192.168.0.101; это ip адрес dhcp сервера 
         Далее в этом фалйе ищет строчку: This is very basic subnet  declaration. Не трогаем эту строчку а спускаемся ниже и нам надо раскоментировть 3 строчки 
											                 1.subnet это маска подсети 
													 2.range это диапозон  доступных ip адресов 
                                						 			 3. скобочку.
	Так же между строчками subnet и range пишем строчку athoritative - ог покажет что данный dhcp сервер являтся основным и предпочтительным в сети, если можно достучаться до нескольких мест 


	  Теперь редактируем третий файл vim /etc/network/interfaces  это необходмо для того чтобы у нешего сервера был статический ip адрес 
														1. В строчке iface inet status static это означает что у нас будет постоянный ip адрес
														2. Добавляем строчку address 192.168.0.100 это ip адрес нашего хоста 
														3. Добавляем строчку network 255.255.255.0 это маска подсети		

После того как мы отредактировали файла нам необходимо перезагрузить серер. После этого можно посмотереть статус сервера  с помощью команды sysemctl status isc-dhcp-server зеленым цетом будет слово aktiveесли оно выделено зеленым то все получилось.


Обеспечения доступа по ssh 
	1. Скачиваем openssh-server на наш сервер ssh (apt install openssh-server). После этого проверяем статус с помоощью команды systemctl status ssh. 
	   Ели все хоршо вы увидите, что зеленым цветом выделено aktive (running)

        2. На другой сервер с которым мы хотим взаимодействовать, а именно заходить на ssh server, мы ставим ssh клиент командой ( apt install openssh-client)

Так же нам необхоимо изменть номер порта, так как стандртный порт для ssh это 2222 и злоумышленники знают об это, и в первую очередб провеят это порт. И нам надо поменять порт. Как это сделить. 
	заходим в файл с помощью vim. vim /etc/ssh/sshd_config в этом файле ищем стройчку порт и менеян порт на другой, напимер на 2239 (port 2239) перед запись это строчку надо раскоментировать. 
	после изменение надо перезагрузить данню службу командой  systemctl restart ssh
Допустим нам надо с помощью ssh перенести файл на сервер, Мы это можем сделать вот так 
						scp -P 2239 /root/5.txt root@192.168.122.231/root 

Первая часть команды означает  откуда  scp -P 2239  /root/5.txt а именно   -P 2239 это порт его нужжно писать с большой буквы  root откуда мы хотим передать 5.txt что бы хоим передать, а нашем случае файл 5.txt 
Вторая часть команды означает debian@192.168.122.231/root куда мы хотим перенести файл  debian@192.168.122.231 имя пользователя и его ip адрес кому мы хотим перреместить файл 
Так же мы можем наоборот взять какой то файл из сервеа
						scp -P 2239 root@192.168.122.231:/root/1.txt /root/
В данном случае нам команда говорит  scp -P 2239 root@192.168.122.231 присоедениться по ssh на порт -P 2239 пользователем root на тако то удаленный серве 192.168.122.231, затем воти в каталог root 
взять файл 1.txt и скопировать его на текущуу машину в каталог  /root/


Огранечение доступа по IP адресам применяется тока для статических ip адресов
		Что нам потребуется, чтобы ограничить досту по ip адресу с которого стучатьс по ssh на нужно отредакировать всего лишь два файла 
													1. vim /etc/hosts.allow тут храняться хосты доступ которых разрешон сервер 
													   и пишем первую строку 
													   sshd: 195.168.121.231 это адрес с котрого мы доступ разрешаем
													2. vim /etc/hosts.deny
													   и пишем 
													   sshd: ALL  (всем запретить кроме тех кому разрешено) 
														И после этого перезагружаем ssh, systemctl restart ssh

Дрступ по ssh по специальным наборам клюючей где установлена служба ssh . Для этого нужно чтобы на локальной машини и серввере был установлен служба openssh-server. Система гинерирует два ключа, одн закрытый. SSH ключ помогает заходить на удаленный сервер  без пароля. Это значит нам не нужно кадый раз вводить пароль чтобы войти на удвленный сервер
другой открытый, открытый мы можем передавать 

Для начало гененируем ssh ключь с помощью команды 

     				ssh-keygen - команда для генерации ключа ssh 
Когда мы сгенерировли ssh ключь нам надо скопировать его на другой сервер для того чтобы мы могли на него входить с помоощью ssh 
									ssh-copy-id debian@192.168.150.158 команда для копирования ssh ключа на дугой сервер debian@192.168.150.158 сервер куда нам нужно 
									перенасти ssh ключь (публичный) 

Если у пользоватля нет ssh ключа и нам надо ему запретить вход по паролю, на надо отредаркировать один файл vim /etc/ssh/sshd_config после того как мы зашли в этот файл, нам надо найти строчку 
PasswordAuthentication раскоментировать и поствить знечения no. Должна получиться такая строчка  (PasswordAuthentication no) после изменения обязательно перезагружаем ssh команой (systemctl restart ssh)

Systemctl: Это система инециализации оперрациоонной системы и управление службами в ней и так он нужн для запуска демона 

Демон (deamon) в Linux - это процесс который работает в фоновом режиме без прямого участия пользователя.
 
Демоны являются частью операционной системы и обеспечивают ряд функций, таких как службы сети, дисковые службы, службы печати и т.д

Обычно демоны запускаются при старте ситстемы и остаются активны а фоновом режиме, пока ситема не будет выключена. Они не имеют прямого интерейса пользователя и обычно управляются через коонфигурационные файлы или команды командной строки.

Демоны в линукс обычно имеют имя, заканчивающиеся на букву "d" например httpd, named и sshd. Они запускаются с поомощью с помощью спциальных команд. такие как systemctl, service или daemon. 

Демоонов еще называют фоновые службы

Структура команды systemctl 
	systemctl команда(что делаем) объек(над чем делаем) 

Чтобы процесс (демон) не запускался в фоновом режиме после перезагрузки мы можем его выключить командой disable
						Пример: systemctl disable sshd - данная команды выключить  ssh сервер, чтобы он осле ребта не работал в фоновом режиме.. 

Чтобы сервис рабтал в фоновом режиме его надо запустить командой enable
						Пример: systemctl enable ssh.service - данная команда позволяет  включить ssh сервис в фоном режиме. 

После того как мы с помоощью команы enable запустили сарвиc, нам надо его запустиь руками с помощью команды start (systemctl start sshd)


Концпция безопасности SU и SUDO 

Чтобы нам добавить sudo для пользователя нам сначало необходимо sudo скачать (apt install sudo). После этого мы с помощью кманды su -l заходим в root и редактируеум файл sudores его нужно открыть 
с помощью команды  visudo

После того как мы открыли sudores  помощью visudo, там нам надо отрдактировать две строчки 
						1. User privillege specification
							root ALL=(ALL:ALL) ALL
						2. Allow member of group sudo to execute any command   
							%sudo ALL=(ALL:ALL) ALL   Если строка начинается со знака % это означает что мы говорим про некую группу \

Под строкой  User privillege specification мы добавляем  нового пользователя и наделаем его полными правами 
							Пример: prod ALL=(ALL:ALL) ALL

Что означает ALL.
	1. На каком хосте 
	2. От имени какого пользователя 
	3. От имени каких групп 
	4. Что именно
Должна получиться вот такая строчка 
		 User privillege specification
			root ALL=(ALL:ALL) ALL
		       	prod ALL=(ALL:ALL) ALL
Строчку root не трогаем

Если нам необходимо выполнить нкую команду от какого либо пользователя мы пишем вот такую команду. Наприер нам надо выполнить команду от пользователя (mike)
							sudo -u mike date      (-u от какого пользователя)

Так же можно сдедать так чтобы visudo был общий на некую группу хостов от туда будет все считываться и права на каждом хосте будут свои или на группе хостов.

Допустим их 5.  У пользователей трех можно будет некоторые вещи делать, а ну двух других нельзя ну или можно, но с паролем или еще с чем нибуть

											Пример: natasha ALL=(ALL:ALL)   NOPASSWD:ALL, PASSWD:/bin/date
NOPASSWD:ALL - без пароля она может запускать все 
PASSWD:/bin/date но с паролем она будет запускать /bin/date


IPROUTE2: параметры и базовая маршрутизация 
			ping 8.8.8.8 проверить работает ли вертуальный маршрутизатор.

Самая простая конструкция которая есть у данной утилиты это 
						ip опции объект команда 
	     					ip link show - команда покажет два неких интерфейса 
первый интерфейс это 
		lo <LOOPBACK, UP, LOWES_UP> это интерфейс, который замыкает устройство на саму себя, он использутся для диагностики или настройки
Во втором интерфейсе нам важен параметр  (mtu) по сути эт максимальный размер кадров данных, который может быть передан 1500 байт 
					link/ether это мак адрес
 
ip linc show можно отсортировать по устройству 
				Пример: ip link show enp1s0 отоброзит информацию тока по данному устройству 

Конфигуррация 
	ip link set устройство параметр значения 
	Пример: ip link set enp1s0 down эта команда позволяет отключить устройств, в данном случае это enp1s0
		И мы видим что состояние (state DOWN) выключена 
Теперь включим устройство 
		ip link set enp1s0 up (включает устройство) 

Если мы хотим поменять размер кадров (mtu 1500)
			sudo ip link set enp1s0 mtu 1000 клманда позволяет изменить размер кадров

Так же можно поменять мак адес устройства 
			sudo ip link set enp1s0 address 00:0c:29:12:01:01
Чтобы пооменять мак адресс надо сперва выключить устройство командой sudo ip link set enp1s0 down
После того как поменяи мак адресс нуждо вклчить устройство командой  sudo ip link set enp1s0 up
В виртуалной машине мак адрес можно менять тока до трех или четырех блоков.

Так же с помощью этой утилиты мы можем пооменять ip адресс устройства 
						   sudo  ip a add 192.168.150.162/24 dev enp1s0 этой командой мы поменяли ip адресс у устройства enp1s0
Такой айпи адресс будет вторичный будет наисанно (secondary) Если система не знает через какие адреса взаимодействовать, он выберет первичный адрес
Так же адалять вторичные адрса можно безболезненно, но если удалить первичный адрес то и удаляться и все втрричные 

Так же мы можем удалить айпи адрес 
		sudo  ip a delete 192.168.150.162/24 dev enp1s0
Когда мы удалим айпи адес и потом добавил, у нас не будер рабоать шлюз по умолчанию. это шлюз нужн для того, что если не знаешь куда слать пакет, шли егов в шлюз по умолчанию

И по этома нам надо задать адрес шлюз по умоланию который пропал.

Как его посмотреть 
	ip route show данная команда покаже к какому ip адресу мы подключены 

Чтобы задать ip адресс шлюзу по умолчанию мы используем команду 
						sudo ip route add default via 192.168.122.1 (тоесть добавить маршрут по умолчанию через точку входа на наш шлюз 192.168.122.1)

Если у нас не получилось задать ip адресс 192.168.122.1 то нам надо прописать другой 192.168.122.2. Но перед этим удалить предедущий так как он все равно стоит 
						sudo ip route delete default команда которая удаляет старый ip в шлюзе по умолчанию.


Разворачиваем  Netbox
            устонавливаем vim, curl, postgresql

Теперь поиграем с базой данных 
		sudo -u postgres psql (-u означает что мы хотм зайти в бд от какого то поьзователя) заходим в бд 

Теперь нам нужно создать саму базу 
			CREATE DATABASE netbox; ( мы создали базу данных с именет netbox)

Далее создаем пользователя для базы данных и пароль
			CREATE USER dev WITH PASSWORD '12345'; ( мы создали пльзователя dev и пароль '12345')

Теперь нам надо дать права пользователю на созданную базу данных netbox
				GRANT ALL PRIVILEGES ON DATABASE netbox TO dev; (мы дали права для пользованию базы данных natbox для пользователя  dev

Чтобы выйти из базы данных нажно ввести команду \q


Теперь проверить что postgresql работает корректно
			pqsl --username dev --password --host localhost netbox (мы сейчас зашли на созданную ранее базу данных с именем netbox)

Чтобы проверить инормацию про базу даных вводим вот такую команду
					\conninfo (покажет на какую базу данных вы подключены под каким пользователем какой сервер, какой адресс и какой порт)

Теперь нам надо становить REDIS это система для управление базами дданных 

в NetBox redis используется для постановки неких  задачь в очередь 

Redis - это нерелционная система управление базами данных(СУБД) которая работает с различныи типами даных, такими как строки, списки, хеши, множества

Работа с данными Redis осуществляется про принципу "ключь-начение" В системе нет языка SQL, но можно использовать lua крипты.

Redis отличается повышенной производительностью за счет хранения данных в оперативноя памти сервера

Основные задачи которые решает Redis:
	- Хранение сессий пользователей, фрагментов сраниц с сайта и других элементов
	- Хранение таких типов данных, сообщения на стене пользователей в соцсетях, голосование, результаты в табличном виде
	- Создание новостных лент групповых чатов, блогов 
	- Кэшировние данных
 	- Хранение данных, к которым требуются предоставить быстрый доступ

Установка и настройка Redis
		apt install redis-server (команда для устанвка  redis)
		redis-cli ping (если он работает то в кансоли покажет значение PONG)

Теперь нам надо скачать пакета для того чтобы в автоматизированном режиме все этапы развертывание прошли
	apt install -y python3 python3-pip python3-venv python3-dev build-essential libxml2-dev libxslt1-dev libffi-dev libpq-dev libssl-dev zlib1g-dev

После этого обновим pip 
	pip3 install --upgrade pip

Если не получается обновить pip можно сделать это принудитено 
		pip3 install --upgrade pip --break-sytem-packages



Тепрь нам надо NetBox притянуть к репозиторию гитхаба (GitHub) 
			apt install git ( устонавливаем гит) 

Далее захоим в корневую папку 
		cd / (команда чтобы ввойти в корневой репозиторий) 

Там находим репозиторий с именет opt, эта папка испоьзуется для хранние дополнительного ПО

Теперь в папку opt подтягиваем сам NetBox из ветки мастер 
				git clone -b master --depth 1 https://github.com/netbox-community/netbox.git
Теперь добавляем нового пользоователя для работы с NetBox
					adduser --system --group netbox (команда чтобы добавить номоого пользователя)

Далее менем владельца группы на netbox
			chown -R netbox /opt/netbox/netbox/media/ ( пользователю даем права над каталогими /opt/netbox/netbox/media/)

Далее начинаем заниматься конфигурацией 
			cd /opt/netbox/netbox/netbox/ (проходим о этому пути, там лежат конфигурационные файлы нам нужен файл под названием configuration_example.py нам нужнос ним поработать)
Для начало мы его скопируем   
		cp configuration_exampe.py configuration.py (мы его скорпироваем туда же где и лежит оригинальный файл) 
Мы будм редактировать копию а именно configuration.py
				vim configuration.py (открыли файл с помощью vim) 
Сперва надо изменить строчку ALLOWED_HOSTS = [] на в квадратные стокобки нужно написать ip адрес нашего хоста 
							ALLOWED_HOSTS = ['192.168.122.231]

Далее в строке DATABASE = заполняем некоторые колонка а именно имя пользоавтель которго мы зоздали для бд 'USER',  пароль  PASSWORD который мо тоже задовали при создании бд 
					'USER': = 'dev'
					'PASSWORD': = '12345'

Далее переходим к параметру SECRET_KEY он будет находиться ниже. этот ключ можно сделать самому. но у нас есть специалный файл для гинерации этого ключа нам нао перейти на одну директория вверх 
					cd /opt/netbox/netbox/ ( файл будет называться generation_secret_key.py) его нужно выполнить 
					python3 generation_secret_key.py (с помощью этой команды мы запустили этот файл или выолнили его) 

Нам каким то образом надо добавить ключь который сгенерировался в наш файл configuration.py. Для этого мы этот ключ генерируем в спциальный файл 
					python3 generation_secret_key.py >secret.txt и после этого мы его копируем в директорию netbox где находиться файл configuration.py
					cp secret.txt netbox/secret.txt

Далее заходим опять в нам файл configuration.py и открываем второе окно 
				split secret.txt (команда позволиcdт открыть втрое окно с файлом secret.txt. и мы от туда возьмет включ)
					
Когда открылось второе окно нажимаем 'v' на клавиатере, выделяем все после это нажимает 'y' копируем все. далее переходим в окно ниже с помощью ctrl+w трелку вниз находим строску SECRET_KEY и с помощью
кнопка 'p' вставляем ключь между ковычек. сохраняем изменеие я выходим из vim

На этом базовые настройки закончилис. 

Начинаем выполнять сценарий оболочки который отвечает за обновления всех файлов, создание локальной документации, миграци баз данных и т.д

Переходим на два репозитория (уровня) выше 
			cd .. cd .. (вы должен быть вот такой путь /opt/netbox)
Там будет файл, точнее баш скрипт upgrade.sh его нужно выполнить 
			bash upgrade.sh	
   
Посе того как сработа скрипт му нас в директории /opt/netbox появиться директрия venv.

Нам надо зайти в venv
		cd venv

Далее там будет биректори bin, переходим в bin 
		cd bin

И в этой директории будет будет лежать скрипт activate его ужно актиировать
					source activate (активировали скрипт)

У нас появиться некое преглошени по основной консоли, как понять что вы в основной консоли 
				(venv) root/debian:/opt/netbox/venv/bin ( вент кторая нахолится в начале строки, означет что вы в консоли) 

Чтобы выйти из venv напишите deactivate

Далее переходим в дирктрияю сd /opt/netbox/netbox/ там бует находиться скрипт manage.py. С помощью питона и исползуя manage.py мы создадим супер пользователя для работы с нашим NetBox
				python3 manage.py createsuperuser
Если не поучается создать супер пользователи и если у вас дистрибутив линукса Ubuntu или Debian 12 то нужно сделть юзера netbox владельцем бд. Зайти в бд и написать 
				ALTER DATABASE netbox OWNER TO netbox;

Теперь попробуем запустить наш NetBox сервер в режиме разработчика ( он не долен рабтать в режиме разрабтчика, но это можно сделать но это не безопасно ) 
				python3 manage.py runserver 0.0.0.0:8000 --insecure в консоле введем эту кманду. чтобы опасть в приложние NetBox:
