команды лннукс

touch создает текстовый документ( файл) 
whoami команда чтобы узнать кто мы
pwd где я
history  показвает историю команд которыми мы пользовались
ls -l вывдит информацию о файле, какое права, размер, дату и время создания
ls -a команда позволяет посмотреть файлы которые начитаются с точки 
ls -al команда позволяет увидеть кто создал файл, когда создал файл и кто его может использовать 
heat -n вывдет первый 10 строк фала

tail -n выводит посоедние 10 строк файла 

less позволяет прочитать большой файл и листать его. Если нам нужно найти конкретоные символы или слова мы пишем слеш(/) и т что хотим найти

| позволяет объеденять команды 


cat позволяет посмотреть что находиться в файле. но так же мы можем с помощью него создавать файл
или заменять содержимое файла в другой файл, с помощью (>) также мы можем дополнить файл другими данныи из другого файла (>>)
Пример: cat 1.txt>2.txt мы из файла  1.txt перекинули информацию в файл 2.txt  Помните что одна (>) удаляет сатарую инфу в файле и и переписует его новой инфой. 
Пример: cat 1.txt>>2.txt мы взяли инфу из 1.txt и дополнили ее в 2.txt
Так же мы можеи брать информацию из других файлов и передавать его в друго файл ипользуя тока одну стрелочку (>)

gpep позволяет искать информацию по каким либо строчкам 
Пример: grep it<1.txt Мы ищем  все строчки где есть слово it в файле 1.txt

mount нужна для подключения (монтирования) файловых систем и персональных накопителей (usb-флешка, карты памят) 
к конкретным точкам монтирования в дереве директорий. 

Пример: mount -t тип файловой системе - ключи опций - непосредственно устройство  - куда? тоесть точка монтирования 
mount /dev/fd /home/nikolay/
такж команда maunt позволяет переносить данные из флешки в любую директорию линукса.

Основные опции команды mount

-t — тип монтируемой файловой системы
-v — подробная информация о процессе монтирования
-a — примонтировать все устройства, описанные в fstab
-f — холостой запуск — что будет сделано при реальном запуске
-r — монтировать файловую систему только для чтения
-w — монтировать файловую систему для чтения и записи
-U — монтировать файловую систему по UUID
Основные опции монтирования

ro — смонтировать файловую систему только для чтения
rw — смонтировать файловую систему для чтения-записи
sync — операции ввода-вывода в ФС должны выполняться синхронно
async — операции ввода-вывода в ФС должны выполняться асинхронно
exec — разрешить выполнение двоичных файлов
auto — ФС может быть смонтирована при запуске mount с опцией -a
noauto — ФС может быть смонтирована только явно
defaults — эквивалентно rw,suid,dev,exec,auto,nouser,async

umount команда для размонтирования 
Пример: umount то что мы хотим размонтировать. 

чтобы удалить замонтироваемый диск его сперва мужно размонтировать командой umnout 


Управление пакетами. 

Репозиторий это набор програмного обеспечения которая собрана отосительно какой либо библиотеке 

Чем пакет отличается от некого  инстолятора: 
Инстолятор это пу сути то что имеет в себе некую сущьность для разертывание програмного обеспечения. 
У пакета структура другая. Он состоит из само собой програмноо обеспечения которая развертывается, он так же состоит из следующих вещей, которая четка прям диклорированы (объявлены) внутри каждого пакета 
Это и конфигурационные файлы 
Это и некая управляющая информация, которая в том числе  используется для развертывание програмного обеспечения 
Контролные суммы всех файлов, они тоже храняться в пакетах. Это постустоновочные неки скрипты, тоесть что нужно сделать после развертывание пакета в системе 
Если вязить приимер из винды. это работает так. мы устанвили програму и на рабочем столе появися ярлык програмы ( значек) ну как пример постустановочного скрипта/ команда поиска в vim 
Так же в пакете храняться скрипты которые будут вызываться перед удаением пакета 
И набор неких скриптов которые вызываются уже после удаление пакета   

dpkg можно использовать в место apt но это очень опасно и он самый нижний уровень по управлению пакетов, по утмновке по удалению 

apt это утилита для установки пакетов. Но она внутри себя так же использует утилиту dpkg и базаруется именно на ней 
apt пр установки всегда следит за зависимотями и вседа подтягивает пакеты и после это гарантировно будет работать 
update команда чтобы посмотреть если ли обновления или нет 
upgrade обновлет пакета не удаляя старые версии. Но она не может поменять на другую версию. а просто ее обновит до последней версию.

Основные команды: для утилиты apt
  list - показать список пакетов на основе указанных имён
  search - искать в описаниях пакетов
  show - показать дополнительные данные о пакете
  install - установить пакеты
  reinstall - переустановить пакеты
  remove - удалить пакеты
  autoremove - автоматически удалить все неиспользуемые пакеты
  update - обновить список доступных пакетов
  upgrade - обновить систему, устанавливая/обновляя пакеты
  full-upgrade - обновить систему, удаляя/устанавливая/обновляя пакеты
  edit-sources - редактировать файл с источниками пакетов
  satisf- удовлетворить строки зависимосте

apt moo посхалка 

Vim команды 

shift+a команда для редактирование 
:q команда выхода из редактора 
:w сохранить изменения(если файл без имени то после ввода команды добавить имя) Пример: :w имя файла 
dd  команда чтобы удалить отдельную строку  
shift+v выделает полностью строку 
v можно выделеить самостоятельно 
y копирует строку 
p вставляет скопированый текст 
set number комнда нумерует строки 
shift : чтобы перейти в режим ввода команд
split команда которая позволяет откруыть второе окно редактора. Привер: split имя файла (если нет файла он его создаст)
vsplit откроет второй файл то тока откроят его вертикальный.
ctrl+w+курсор команда чтобе переходить между открытыми окнами редактора. Или ctrl+ww
wq команда чтобы сразу записать файл и выйти из него 
/ команда поиска в vim 
n команда чтобы переходить по найденным значением с помощью поисковика vim 
shifn+n команда чтобы вернуться на предедущее значения в поисковике vim 


Управление пользовательскими группами 

Лонгин и пароль, это первичный способ защиты и идентификации, но не является однозначенным способом идентифицировать пользователя 

Группа это способ объеденения пользователей чтобы раздавать им центаризованные права ну или лишать их 
Операционная система незнает пользоваьеля там с именем Маша, Коля, или Юра 
Операционная система работает тока с UID идетификатором пользователя 
UID или USER ID Это уникалый идентификатор, назначенный каждому пользователю в системе
Он используется для определения тех, кто владеет файлами и каталогами и какие права доступа у них есть.
UID может быть любым числом от 0 до 65535. В большенство дистрибутивов Linux UID 0 зарегестрирован для суперпользователя (root)
GID или Group ID. Это идентификатор группы, назначенный каждой группе пользователей в системе. 


Создане пользователей, модификация и удление
 
useradd команда для создание пользователй
 
/etc/paswd/ в этой директории храняться данные о пльзователей

getent команды чтобы делать выборку из файла и так жк можно проверять наличие новых пользователей

Пример: getent passwd Ylia - этой командой мы смотрим есть ли  у нас в системе пользователь Ylia. И он нам покажет результат. Соответственно это все надо делать с правами супер пользователя.
        Ylia:x:1001:1001::/home/Ylia:/bin/sh  и так, мы видим, что такой пользователь есть. У него 10001 номер, система сама назначает номер, 10001 группа, так как они так же не занята,
        его домашняя директория /home/Ylia и его шел (shell)  /bin/sh
	useradd kliff -m -d /home/kliff -k /home/nikolay -s /bin/bash 
	Описания:: мы хотим создать пользовтеля с именем kliff, -m -d это ключит для домашней директори /home, -k откудо подтянть файлы, мы подтягиваем файлы из /home/nikolay, все файла которрые хрянаться 	    в домашней директории /home/nikolay появятся у пользователя kliff, и оболочка /bin/bash. Так как мы скопировали файлы и директории /home/nikolay то пользователь kliff может их изменять, 
	так как у него есть полный доступ на них
 
        shell(оболочка)  Это команда обеспецивающая взаимодействие пользователся с системой.  В командной строке вы вводите команды, котрые оболочка интерпритирует, вызывает
        соответствующие прогаммы и отоброжает результаты. Команды могут подаваться не только в текстовом режиме, но и считываться из файла, называемого shell-скриптом или оболочкой shell-программы
        Поосле того как мы создали новоого пользователя и чтобы он мог войти, нужно создать ема пароль командой passwd Ylia(имя пользовател)
        passwd кооманда для создания пароля для пользователей.
        Но когда пользователь Ylia зайдет на свой создынный аккаунт, у нее там не будет домашней директории. и ее нужно создать, командой mkdir Ylia(имя домашней диретории) 


	Bash это командная оболочка для UNIX-подобных операционных систем (Linux, MacOS). ОНа преедставляет пользователю систему команд для работы с файлами и папкими, поиском, настроойкой окружения и 
	позволяет управлять ОС прям с командной строки 
	Оболочка принимает команды,  которые пользовтель ввл в командную строку, и интерпритирует их, то есть переволит в машинный код. Операционная система получат код в качестве инструкций и выполняет
	их
	Так же можно создавать bash или shell-скрипты, которые сохраняются в файле. При каждом запуске файла будет выполняться набор указанных в нем команд 




        
cat /etc/nsswitch.conf  он показывает то откуда подтягиваются информация для поиска данныз о пользователях, группах и т.д. Это список источноков

Но у нас есть возможность  автоматизировать процесс созданиие пользователей 

adduser создает пользователей в системе.
 
	Она работает на более высоком уровне и является интерактивной. При использования adduser достаточно задать имя пользователя, а далее  утилита автоматически создаст одноименную группу для 
	пользователя, 
	домашний каталог в директории /home, предложит задать пароль, а также заполнит такую информацию, как полное имя, номер кабинета, рабочий телефон, доманий телефон, и 
	любую другую информцию, которую вы посчитаете нужной 
 После того как мы создали пользователя ы увидет такую информацию 
	info: Adding user `igor' ...
	info: Selecting UID/GID from range 1000 to 59999 ...
	info: Adding new group `igor' (1002) ...
	info: Adding new user `igor' (1002) with group `igor (1002)' ...
	info: Creating home directory `/home/igor' ...
	info: Copying files from `/etc/skel' ...
	
	Нам интересна последняя строчка info: Copying files from `/etc/skel' это копирование файлов, которая идет из /etc/skel' это так называемый скелет директории, если вы сюда что то поместите,
	то при создание пользователя оно автоматчски попадет ко всем остальным пользователям. Это может быть какой то набор инструкций, чтобы у каждого ползователя при создании, были одинаковые инструкции

Модификации пользователей 

usermod  с различными ключами, команда чтобы изменять параметры пользователей и также чтобы поменять группу у пользователя 

	-d изменет домашний каталог
	-m -d он переместит домашний катологс его содержимым
	-l изменения имени пользователя. Пример: usermod Ylia -l vova (старрая имя пользователя -l новое имя пользователя)
	-s меняет оболочку. Пример: usermod Ylia -s /bin/bash (имя пользоватля -s оболочка /bin/bash)
	-r удаляем все каталоги и файлы из в месте с ползователем
	-g чтобы поменять или добавить главную(первичную)  группу для пользователя. Пример: usermod -g имя новой  группы. Каждый пользователь должен принадлежать ровно одной основной(первичной) группе 
        -G чтобы добавить вторичные группы. Можно добавлять несколько вторичных групп срузу, чрез запятую. Пример: usermod Ylia -G igor, cdrom, natasha. Мы для пользователя Ylia добавили три вторичные 
	группы igor, cdrom, natasha. Так же моожно первичную группу селать вторичную, и на оборот   
	-a команда которая позволяет добавить к вторичным группам еще одну группу, не удаляя старые группы 
	-s позволяет менять оболочки, на любоу другую. Напаример можно заблокировать доступ пользователя в первичную группу написав команду (usermod Ylia -s /bin/false или usermod Ylia -s /sbin/nologin. 
	   Грубо говоря мы 
	   мы поставили загрушку для пользователя Ylia чтобф он не мог войти к себе в группу.
userdel удаляет пользовтеля из системы но не удалет его файлы. Чтобы удалить и пользователя и файлы надо написать ключ -r
	Пример: userdel -r имя пользователя


Назначения групп

Основа распределения прав доступа в в операционной ситеме в Linux лежит на понятии пользователь. Пользвателю владельцу файла выдаются определенные полномочия для работы с ним, а именно чтение, запись, и 
исполнеения.
Так же отдельно устонавливаются полномочия на чтения, запись и выполнени для всех остальных пользователей. Посколку в линуксе все есть файл, то такая система позволяет регулировать доступ к 
любому действию в этой операционной системе с помощью установки прав доступа на файлы 
	Группа в linux нужна для разгроничения прав доступа к различным компонентам системы.
	Каждая группа, как и отдельный пользователь, обладает набором прав и доступа к различным компонентам системы. Каждый пользователь член этой группы автоматически получает все права вэтой группы 
	
	Группа позволяет группировать пользоветелей по принцыпу одинаковых полномочий  на какое либо действия. Каждый пользователь может состоять в неоограниченном количестве групп,	
	и в каждой может быть сколько угодно пользоователей. 

В Linux сущестует два типо групп для ползователей
	1. Первичная группа (группа входав систему) - эта группа которая назначается файлам, создавамым пользователем. Обычно имя основной группы совпадает с именеп пользователя.
	   Каждый пользователь должен принадлежать ровно к одной основной группе.
	2. Вторичная грууппа (допонительная группа)  - это группа, которая использует для предоставления определенных привелеегий пользователю. Пользователь может быть участником не оной а сразу 
	   нескольких вторичных групп 
	

Группа у каждого пользоатля бывает главная и вторичная, все они находяться внутри одного файла. Файл называется ( /etc/group)

groups команада для простотра гуппы пользователя.
addgroup команда чтобы создать группу ( addgroup имя группы которую хотим создать)
groupdel удаение групп 
 
Конфигупация пользователей 

 если мы посмотрим, что нахолиться в директории /etc/motd, то мы увидем сообщени которая у нас появляется при входе в операцинную систему. При необходимости мы можем этот файл отредактировать 
и можем выводить какое нибуть иное сообщение, отличное от исход

Блокировка пользователей

	usermod -L  команда чтобы забокировать пользователя ( -L  ключь для блокировки пользователя) Пример: usermod Ylia -L - мы заблокировали пользовтеля Ylia
	usermod -U  команда для разблокировки пользователя  ( -U ключь для разблокировки пользователя)  Пример: usermod Ylia -U  мы разблокировли пользователя Ylia
	usermod -e  команда поозволяет поставить дату на блокировку пользвателя. Пример: usermod Ylia -e 2024.12.20  Нам надо чтобы пользователь заблокировался 2024.12.20 и он заблокируется в эту дату 

chage команда чтобы посмотреть информацию по пользователю а именно.


 
	   



Символичесие и жесткие ссылки

	Символические и жесткие ссылки - это особенность файловой системы Linux, которая позволяет размещать один и тот же файл в нескольких директориях. 
	Это очень похоже на ярлыки в Windows, так как файл на самом деле остается там же где и был, но вы можете на него сослаться из любого другого места.
	Пользователь не должен существовать в операционной системе бесконечно. почему не должен, он может уволиться а уего учетка останеться и через его учетку могу зайти 

	В Linux существует два типа ссылок на файлы. Это символические и жесткие ссылки Linux. Они очень сильно отличаются и каждый тип имеет очень важное значение. 
	В этой небольшой статье мы рассмотрим чем же отличаются эти ссылки, зачем они нужны, а также как создавать ссылки на файлы в Linux.






Символические ссылки

	Символические ссылки более всего похожи на обычные ярлыки. Они содержат адрес нужного файла в вашей файловой системе. Когда вы пытаетесь открыть такую ссылку, то открывается целевой файл или папка 	    Главное ее отличие от жестких ссылок в том, что при удалении целевого файла ссылка останется, но она будет указывать в никуда, поскольку файла на самом деле больше нет.






Вот основные особенности символических ссылок:

    Могут ссылаться на файлы и каталоги;
    После удаления, перемещения или переименования файла становятся недействительными;
    Права доступа и номер inode отличаются от исходного файла;
    При изменении прав доступа для исходного файла, права на ссылку останутся неизменными;
    Можно ссылаться на другие разделы диска;
    Содержат только имя файла, а не его содержимое.




Теперь давайте рассмотрим жесткие ссылки.

Жесткие ссылки

	Этот тип ссылок реализован на более низком уровне файловой системы. Файл размещен только в определенном месте жесткого диска. Но на это место могут ссылаться несколько ссылок из файловой системы. 	    Каждая из ссылок - это отдельный файл, но ведут они к одному участку жесткого диска. Файл можно перемещать между каталогами, и все ссылки останутся рабочими, поскольку для них неважно имя. 





Рассмотрим особенности:

    Работают только в пределах одной файловой системы;
    Нельзя ссылаться на каталоги;
    Имеют ту же информацию inode и набор разрешений что и у исходного файла;
    Разрешения на ссылку изменятся при изменении разрешений файла;
    Можно перемещать и переименовывать и даже удалять файл без вреда ссылке.

$ ln опции файл_источник файл_ссылки

Рассмотрим опции утилиты:

    -d - разрешить создавать жесткие ссылки для директорий суперпользователю;
    -f - удалять существующие ссылки;
    -i - спрашивать нужно ли удалять существующие ссылки;
    -P - создать жесткую ссылку;
    -r - создать символическую ссылку с относительным путем к файлу;
    -s - создать символическую ссылку.







- d l b c ( c этих символов всегда начинается строка, которая показывает какие права существуют над объектом) 
	- это файл или просто ноль, если мы хотим задавть права на обычный файл 
	d - это директория 
	l - это символьная ссылка. Символьная ссылка (symbolic link) - эта специальный файл, который является ссылкой на другой файл или каталог. 
	    Символьческие ссылки также газывают символьными, мягкими ссылками (soft links) или сим ссылками (sym-link)
            Они не содержат внутри себя копии самого файла, на которрый указывают, и являются всего лишь указателями на файл. При этом символические ссылки обладают собственными правами доступа
            так как сама являтся небольшим файлом, которая содержит путь до другого файла 
            Можно сооздовать несколько символических ссылок на один файл и эти ссылки могут иметь разные имена.
	b - блочное устройство Блочное устройство (block device) — вид файла устройств в UNIX/Linux-системах, обеспечивающий интерфейс к устройству, реальному или виртуальному, 
	    в виде файла в файловой системе. 
	    С блочным устройством обеспечивается обмен данными блоками данных. Как правило, это устройства произвольного доступа, т.е. можно указать, из какого именно места должен быть прочитан или
	    записан блок данных. Данные, при чтении или записи на блочное устройство буферизуются.
            Типичные примеры блочных устройств: жёсткий диск, CD-ROM, флоппи-дисковод. 
            Файл устройства /dev/fd0 флоппи-дисковода: 
	с - символное устройство 
	    Символьное устройство — (character device) — вид файла устройства в UNIX/Linux-системах, обеспечивающий интерфейс к устройству, реальному или виртуальному, 
	    с возможностью посимвольного обмена информацией. 	 	    
            Символьное устройство — (character device) — вид файла устройства в UNIX/Linux-системах, обеспечивающий интерфейс к устройству, реальному или виртуальному, 
	    с возможностью посимвольного обмена информацией. 	
	    В отличие от блочного устройства символьное устройство, как правило, не обладает возможностями произвольного доступа. 
            В большинстве своём, чтение и запись данных в символьное устройство не буферизуется.

            Типичные примеры символьных устройств: стриммер, модем, телетайп или терминал.

            Файл устройства /dev/ttyS0 последовательного порта: 

       -rwxrwxrwx читат-записывать исполнять(read-write-execute). Первые три (бата) значение это то, что может делать над файлом владелец, какого тожет не быть,                                                     	      так же у них есть числовые значения это нужно для того, чтобы менять  права у пользователей
		  r - это чтение
		  w - запись
, 	          x  - это исполнение  
		  Первые три бита(значения)  это то, что может делать над файлом владелец группы 
	          Следующие три (бита) значения  идет, что может совершать над файлом члены группы владельца.(допустим они только могут читать -r-xr--rwx)
	  	  Последдние три (бита) значения - это то, что могут делать над файлом все остальные. (допустим все остальные могут тока исполнять файл -r-xr----x)




Как менять права пользователей:
У прав доступа есть аткже числовые значение - это сдлано для удобства и скорости предоставление прав пррав доступа.
rwxr: r=4 
      w=2,  
      x=1. Для предоставление доступа их сумиркют.

chmod -  команда для изменение прав доступа

Пример: chmod 0761 222.txt (0 (ноль)- это означает что мы хотим дать права на файл, 4+2+1 = 7, 7 означает что мы хотим владельцу дать полные праввав на фал, далее 4+2 = 6 это означает что мы членам группы	     владельца хотим дать права только на чтение и запись. А  для всех остальных только исполнения  
Если нам надо изменить права во всем каталоге то мы приминяем утилиту -R(рекурсивно) 
	Пример: chmod -R 777 linux. Что мы видим, мы доавляем полные  права на все файлы которые находяться в каталоге linux. Всем файлам которые находяться в каталоге linux мы дали права на чтение
	запись и исполнения неограниченно для всех пользователей.

Также чтобы изменять права можно использовать символьные значение(буквенные)
	u - юзира(владельца группы)
	g - это для группы
	o - для всех остальных 
	a - это для всех
Пример: chmod u=w, g=w, o=w 222.txt	 



Изменения пользователя 

		chmod -v root linux.txt (мы у файла linux.txt  меняем права на root тобишь мы меняего поменли его права на супер пользователя) Если не поолучается поменять пользователя, то надо перейти в 
                                        супер пользователя.
		-v показвает какие измнения произошли чтобы посмотреть что у нас будет изменятся 
  		
		chmod -v fox:ylia file.txt (И так что мы делаем: Мы у файла file.txt менем владельца на fox и основная группа изменена на ylia)
		chmod fox: his2  (у his2 владельцем стал fox и группой так же станем fox)
		chmod  :fox his2     ( в этом случае владельца группы мы не поменяи а вот группа поменялась теперь она fox )


бит SUID Set User ID  не безопасная команда, которрая позволяет обойти сисему безопасности действует в ее обход,
		  Она позволяет запустить некое програмное средство от именя хозяина данного средства а не от имени текущего пользователя. Очень редко используют 
бит SGID При этом случае, все файлы получают группу аналогичной родительской директории и соответстенно все остальное наслудует. 
Стики бит дает право удалать чото тока хозяину и владельцу группы.  Если активирован стики бит то удалять файлы сможет тока хозяин и root смогут удалить файлы 

Если мы на скрипт навесили бит SUID то он не будет работаить с правами владельца чтобы он заработал нам надо бит  SUID навесить на сам баш 

Стики бит:
	chmod 1777 fox   (И так, мы на каталоог fox навесили стики бит. 1 означет что у него есть стики бит а 777 это его права рава у него полные rwx, в конце прав появиться буква t)   
		         rwxrwxrwxt- t означает что стки бит на даректории  fox активирвался

Процессы:
	ps - позволяет получить информацию о процессах. он выводит прцессы без ключей для данного терминала 
	    PID TTY          TIME CMD
	    6081 pts/0    00:00:00 bash
  	    28064 pts/0    00:00:00 ps
	TTY - это на каком терминал выполняется 
	TIME - сколько процессового времени заняло 
	CMD - что за команда породила данный процес и так же показывает имя процесса 
	PID -  это идентификатор процесса 
	STAT - показает состояние процесса
	       S - sleep по другому сон ожидание или прирывестый сон, программа ожидает некого дйствия от пользователя либо со стороны другой программы или процесса 
	       R - это значит выполнется в данный момент. показывет что в данный момен выполняется команда. 
	       +  например R+ это означает что в данный момент процесс попал в группу фоновых процессов 
	       Z  процесс зомби- процесс который завршился полноситью, но пока что его не убрали потому что его ен опросил его процесс созддатель. пока завршенный процесс не опросит процесс создатель 
		  он из системы полностью не уберается  
Есть некий исходный процксс который пораждает по цепочке все процессы

top - команда которая позволяе смотреть все процессы.
      PID -  это идентификатор процесса
      PPID - идентификатор родительского процесса. Родительский роцесс это процесс который создал  (продлил) один или несколько дочерних процессов (процессов потомков) 
      USER - колличество текущих пользователей 
      PR - приоритет процесса. Процессы с более высоким приоритетом, будет обслуживаться раньше процессов с более низким приоритетом. Если процесс с более высоким приоритетом требует процессороного 
	   времени , он всегда будет обрабатываться рраньше процессов с более низким приоритетом.
      NI - ребление cpu пользовательскими процессами,и с измененным приоритетом ( командой nice или renice) 
      VIRT - это объем виртуальной памяти, который выделяется под конкретный процесс. Он обозначает общий ресурс, то есть в него входит информация, страницы памяти, коды ошибки и т.д
      RES  - это информация о том, сколько оперативной памяти относитс к процессу и указывается в килобайтах 
      SHR - это часть памяти из RES которую занимают ресурсы, доступны для использования другим процессам
      S - используется для переключения режима кумулятивного времени. Когда накопительный режим вклечен, каждый процесс отоброжется в списке с указанием процессорного времени, которое он и его мертвые
          дочерние процессы использовали. 
      CPU - показвает загруженность процессора 
      MEM - отоброжает сведени об использования оперативной памяти
	    В частности в столбце MEM указаны 
                        total - общий объем памяти 
			free - объем свободного места 
			used - объем использованной памяти 
      TIME+ показывает общее время процессора, используемое процессом м момента его начала, с точностью до сотых долей сукенды. 
      COMMAND показывет какая команда запустила той или иной процесс. 

Запуск процесса с приоритетом: 
Для чего это нужно, нам это бывает нужно, напрмер для того чтобы выдать максимальный приоритет некой программе чтобы он за ночь все это выполнил, тоесть он будет 
иметь максимальный приоитет процесорного времени
	nice - команда чтобы поставить приоритет по вреиени
	nice -n 11 vim file.txt (11 это ПРИОРИТЕТ, vim КОМАНДА, file.txt АРГУМЕНТ) 
 
Так же можно поменять текущий приоритет	 
	renice - позволяет поменять текущий преоритет. 
	renice -n 3 -p 603 (различия в  команды renice от  nice в том что чтобы поменть текущий приоритет с помощью renice нам необходимо знать PID аргумента -p это и есть PID) 

Уничтожение процессов 
		kill - позволяет завешить процесс . Пример: kill 603 - 603 это PID процесса
                killall команда позволяет удалить однотипные процессы 

Так же процесс можно убрать на задний фот  и задать ему определенный период. 
			sleep позволяет процесс перекинуть на задний фон 

	 
Базовые настройки сети линукс

	ip a - команда котора выводит информацию об интеррейсах и их настройках и так же можно посмотреть имя сетевой карты  она находиться в пункте 2
	ip addr add 192.168.0.1/24 dev enp0s3  (24 это маска подсети. Маска подсети разделяет ip адресс  на подсеть и конкретное устройство этой подсети. Он аще выглядит так 255.255.255.0, если 
				    представить это в твоичной ссистеме то мака будет выглядть так 11111111.11111111.11111111.0=24.  dev это значения имени сетево карты
			            это значит что после dev надо написать имя сетевой карты.  enp0s3 это имя сетевой карты)
	ping ip адрес команда чтобы пинговать сеть  
	 



Резвертыване DHCP сервера 
	DHCP-сервер — это специальный сервер, который автоматически распределяет и обновляет IP-адреса и другую информацию конфигурации для новых устройств в сети. 1

        DHCP (Dynamic Host Configuration Protocol) — это сетевой протокол, который упрощает управление и снижает вероятность конфликтов — назначения двум устройствам одного и того же адреса. 2

        На DHCP-сервере хранится список IP-адресов для выдачи, который называется пулом. В него входит один или несколько диапазонов последовательных адресов. 
        Сервер назначает новому устройству IP-адрес и другие параметры сетевой конфигурации — адрес шлюза по умолчанию, время аренды и прочие. 2

        DHCP-сервер облегчает процесс настройки сетевых устройств, включая пользовательские компьютеры, маршрутизаторы, смартфоны и другие.


Чтобы у нас ip адрес не менялся после каждой перезагрузке сервера, нужно поменять имя хоста. Это можно сделать в файле которай находиться по пути /etc/hostname
открываем файла  с помощью текстового редактора vim /etc/hostname и пишем новый имя хоста. старый можно удалить 

Настройка DHCP сервера 
	  Снасало нужно развернуть службу DHCP ее необхоимо скачать apt install isc-dhcp-server \
	  Даллее нам необходимо отредактировай файл vim /etc/default/isc-dhcp-server в этом файле нам надо раскоментировть две строчки и в строчку INTERFACESv4="" добавить имя интерфейса его можно глнуть           написав клманду ip a он будет в колонке 2 
												  1. DHCPDv4_CONF=/etc/dhcp/dhcpd.conf
												  2. DHCPDv4_PID=/var/run/dhcpd.pid
	  Теперь редактируем другой файл он нахолиться по пути vim /etc/dhcp/dhcpd.conf
	  Теперь редактируем третий файл vim /etc/network/interfaces
После того как мы отредактировали файла нам необходимо перезагрузить серер. После этого можно посмотереть статус сервера  с помощью команды sysemctl status isc-dhcp-server зеленым цетом будет слово aktiveесли оно выделено зеленым то все получилось.


Обеспечения доступа по ssh 
	1. Скачиваем openssh-server на наш сервер ssh (apt install openssh-server). После этого проверяем статус с помоощью команды systemctl status ssh. 
	   Ели все хоршо вы увидите, что зеленым цветом выделено aktive (running)

        2. На другой сервер с которым мы хотим взаимодействовать, а именно заходить на ssh server, мы ставим ssh клиент командой ( apt install openssh-client)

Так же нам необхоимо изменть номер порта, так как стандртный порт для ssh это 2222 и злоумышленники знают об это, и в первую очередб провеят это порт. И нам надо поменять порт. Как это сделить. 
	заходим в файл с помощью vim. vim /etc/ssh/sshd_config в этом файле ищем стройчку порт и менеян порт на другой, напимер на 2239 (port 2239) перед запись это строчку надо раскоментировать. 
	после изменение надо перезагрузить данню службу командой  systemctl restart ssh
Допустим нам надо с помощью ssh перенести файл на сервер, Мы это можем сделать вот так 
						scp -P 2239 /root/5.txt root@192.168.122.231/root 

Первая часть команды означает  откуда  scp -P 2239  /root/5.txt а именно   -P 2239 это порт его нужжно писать с большой буквы  root откуда мы хотим передать 5.txt что бы хоим передать, а нашем случае файл 5.txt 
Вторая часть команды означает debian@192.168.122.231/root куда мы хотим перенести файл  debian@192.168.122.231 имя пользователя и его ip адрес кому мы хотим перреместить файл 
Так же мы можем наоборот взять какой то файл из сервеа
						scp -P 2239 root@192.168.122.231:/root/1.txt /root/
В данном случае нам команда говорит  scp -P 2239 root@192.168.122.231 присоедениться по ssh на порт -P 2239 пользователем root на тако то удаленный серве 192.168.122.231, затем воти в каталог root 
взять файл 1.txt и скопировать его на текущуу машину в каталог  /root/





